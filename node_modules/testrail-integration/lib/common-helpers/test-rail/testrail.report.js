"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CucumberRailClient = void 0;
const testrail_implements_1 = require("./testrail.implements");
const cucumber_1 = require("cucumber");
const testrail_1 = require("./testrail");
class CucumberRailClient extends testrail_1.TestRailClient {
    async addAndUpdateTestCaseResult(scenario, runID, caseId, content) {
        try {
            await this.addTestResult(runID, caseId, content);
            const featureFileLocation = scenario.sourceLocation.uri.toString().replace(".feature", "").split("/");
            const jiraRef = featureFileLocation[featureFileLocation.length - 1].toString().split("-");
            const caseResponse = await this.getCase(caseId);
            if (!isNaN(Number.parseInt(jiraRef[1], 10))) {
                const refs = jiraRef[0] + "-" + jiraRef[1];
                if (caseResponse.refs === null) {
                    caseResponse.refs = refs;
                    await this.updateTestCase(caseId, caseResponse);
                }
                else if (caseResponse.refs && !caseResponse.refs.includes(refs)) {
                    caseResponse.refs = caseResponse.refs + "," + refs;
                    await this.updateTestCase(caseId, caseResponse);
                }
            }
        }
        catch (err) {
            throw err;
        }
    }
    async updateTestRailResults(scenario, runID, version) {
        const content = new testrail_implements_1.INewTestResultImpl();
        let caseBug = null;
        const caseIDS = new Array();
        for (const tag of scenario.pickle.tags) {
            if (tag.name.toLowerCase().includes("@bug-")) {
                caseBug = tag.name.substr(5);
            }
            if (tag.name.toLowerCase().includes("@c")) {
                caseIDS.push(tag.name);
            }
        }
        content.comment = "Scenario Name: " + scenario.pickle.name.toString();
        for (const newCaseId of caseIDS) {
            const tags = newCaseId.toLowerCase().split("@c");
            if (!isNaN(Number.parseInt(tags[1], 10))) {
                const caseId = Number.parseInt(tags[1], 10);
                if (!isNaN(caseId) && !this.caseIdsMap.get(caseId)) {
                    content.version = version;
                    if (scenario.result.status === cucumber_1.Status.FAILED) {
                        content.status_id = 5;
                        if (caseBug) {
                            content.defects = caseBug;
                        }
                        this.caseIdsMap.set(caseId, true);
                    }
                    else if (scenario.result.status === cucumber_1.Status.PASSED) {
                        content.status_id = 1;
                        this.caseIdsMap.set(caseId, false);
                    }
                    else if (scenario.result.status === cucumber_1.Status.PENDING || scenario.result.status === cucumber_1.Status.UNDEFINED ||
                        scenario.result.status === cucumber_1.Status.SKIPPED || scenario.result.status === cucumber_1.Status.AMBIGUOUS) {
                        content.status_id = 4;
                        this.caseIdsMap.set(caseId, false);
                    }
                    scenario.pickle.steps.forEach((value) => {
                        Object.keys(scenario.result).forEach((key) => {
                            if (key.includes("exception")) {
                                content.comment = "Scenario Name: " + scenario.pickle.name.toString() +
                                    "\n" + scenario.result.exception;
                            }
                        });
                        Object.keys(value).forEach((prop) => {
                            if (prop === "text" && scenario.result.status === cucumber_1.Status.AMBIGUOUS) {
                                content.comment = scenario.pickle.name.toString() +
                                    `\n Step is Ambiguous. Multiple step definitions match: \n ${value[prop]}`;
                            }
                            else if (prop === "text" && scenario.result.status === cucumber_1.Status.UNDEFINED) {
                                content.comment = scenario.pickle.name.toString() +
                                    `\n Step is Undefined. Implement with the following snippet: \n ${value[prop]}`;
                            }
                            const valueprop = value[prop];
                            if (valueprop instanceof Object === true) {
                                Object.keys(valueprop).forEach((subvalue) => {
                                });
                            }
                        });
                    });
                    await this.addAndUpdateTestCaseResult(scenario, runID, caseId, content);
                }
            }
        }
    }
}
exports.CucumberRailClient = CucumberRailClient;
//# sourceMappingURL=testrail.report.js.map